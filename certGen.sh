#!/bin/bash

## Copyright (c) Microsoft. All rights reserved.
## Licensed under the MIT license. See LICENSE file in the project root for full license information.

###############################################################################
# This script demonstrates creating X.509 certificates for an Azure IoT Hub
# CA Cert deployment.
#
# These certs MUST NOT be used in production.  It is expected that production
# certificates will be created using a company's proper secure signing process.
# These certs are intended only to help demonstrate and prototype CA certs.
###############################################################################

set -x # Set trace on
set -o errexit # Exit if command failed
set -o pipefail # Exit if pipe failed

root_ca_dir="."
home_dir="."
algorithm="genrsa"
COUNTRY="TW"
STATE="TPE"
LOCALITY="Redmond"
COMMON_NAME=${2}
ORGANIZATION_NAME=${3}
root_ca_password=${4}
days_till_expire=${5}
intermediate_ca_password=${6}
key_bits_length="2048"
ca_chain_prefix="chain"
intermediate_ca_dir="."
openssl_root_config_file="./openssl_root_ca.cnf"
openssl_intermediate_config_file="./openssl_device_intermediate_ca.cnf"
root_ca_prefix="root.ca"
intermediate_ca_prefix="intermediate"

RABBITMQ_IP=${10}
RABBITMQ_DNS=${11}
EXTENSION_NAME=${12}

function makeCNsubject()
{
    local result="/CN=${1//\"/}"
    case $OSTYPE in win32) result="/${result}"
    esac
    echo "$result"
}

function makeCsubject()
{
    local result="/C=${1}"
    case $OSTYPE in win32) result="/${result}"
    esac
    echo "$result"
}

function makeOsubject()
{
    local result="/O=${1}"
    case $OSTYPE in win32) result="/${result}"
    esac
    echo "$result"
}

function warn_certs_not_for_production()
{
    [ ! -z "$TERM" ] && tput smso
    [ ! -z "$TERM" ] && tput setaf 3
    echo "Certs generated by this script are production"
#    echo "This script is only to help you understand Azure IoT Hub CA Certificates."
#    echo "Use your official, secure mechanisms for this cert generation."
    echo "Also note that these certs will expire in ${days_till_expire} days."
    [ ! -z "$TERM" ] && tput sgr0
}

function generate_root_ca()
{
    local common_name="${COMMON_NAME}"
    local password_cmd=" -aes256 -passout pass:${root_ca_password} "

    cd "${home_dir}"
    echo "Creating the Root CA Private Key"

    openssl "${algorithm}" \
            ${password_cmd} \
            -out "${root_ca_dir}/private/${root_ca_prefix}.key.pem" \
            ${key_bits_length}
    [ $? -eq 0 ] || exit $?
    chmod 400 "${root_ca_dir}/private/${root_ca_prefix}.key.pem"
    [ $? -eq 0 ] || exit $?

    echo "Creating the Root CA Certificate"
    password_cmd=" -passin pass:${root_ca_password} "

    openssl req \
            -new \
            -x509 \
            -config "${openssl_root_config_file}" \
            ${password_cmd} \
            -key "${root_ca_dir}/private/${root_ca_prefix}.key.pem" \
            -subj "$(makeCNsubject "${common_name}")$(makeOsubject "${ORGANIZATION_NAME}")" \
            -days ${days_till_expire} \
            -sha256 \
            -extensions v3_ca \
            -out "${root_ca_dir}/certs/${root_ca_prefix}.cert.pem"
    [ $? -eq 0 ] || exit $?
    chmod 444 "${root_ca_dir}/certs/${root_ca_prefix}.cert.pem"
    [ $? -eq 0 ] || exit $?

    echo "CA Root Certificate Generated At:"
    echo "---------------------------------"
    echo "    ${root_ca_dir}/certs/${root_ca_prefix}.cert.pem"
    echo ""
    openssl x509 -noout -text \
            -in "${root_ca_dir}/certs/${root_ca_prefix}.cert.pem"

    # KeyValue private key format pkcs8
    openssl pkcs8 -in "${root_ca_dir}/private/${root_ca_prefix}.key.pem" \
            ${password_cmd} \
            -topk8 -nocrypt \
            -out "${root_ca_dir}/private/${root_ca_prefix}.pkcs8.pem"

    warn_certs_not_for_production

    [ $? -eq 0 ] || exit $?
}



###############################################################################
# Generate Intermediate CA Cert
###############################################################################
function generate_intermediate_ca()
{
    local common_name="${COMMON_NAME}"
    local desired_inter_ca_idx="${1}"
    local source_chain_file="./intermediate_ca/chain-${1}.ca.cert.pem"
    local PARAMETER="server_ip=${RABBITMQ_IP} server_dns=${RABBITMQ_DNS} intermediate_idx=${desired_inter_ca_idx}"
    echo "PARAMETER: $PARAMETER"

    local password_cmd=" -aes256 -passout pass:${intermediate_ca_password} "
    echo "Creating the Intermediate Device CA"
    echo "-----------------------------------"
    cd "${home_dir}"

    openssl "${algorithm}" \
            ${password_cmd} \
            -out "${intermediate_ca_dir}/intermediate_ca/${intermediate_ca_prefix}-${desired_inter_ca_idx}.key.pem" \
            ${key_bits_length}
    [ $? -eq 0 ] || exit $?
    chmod 400 "${intermediate_ca_dir}/intermediate_ca/${intermediate_ca_prefix}-${desired_inter_ca_idx}.key.pem"
    [ $? -eq 0 ] || exit $?


    echo "Creating the Intermediate Device CA CSR"
    echo "-----------------------------------"
    password_cmd=" -passin pass:${intermediate_ca_password} "
    echo ${PARAMETER} \
    openssl req -new -sha256 \
        ${password_cmd} \
        -config "${openssl_intermediate_config_file}" \
        -subj "/CN='${common_name//\"/}'$(makeOsubject "${ORGANIZATION_NAME}")" \
        -key "${intermediate_ca_dir}/intermediate_ca/${intermediate_ca_prefix}-${desired_inter_ca_idx}.key.pem" \
        -out "${intermediate_ca_dir}/intermediate_ca/${intermediate_ca_prefix}-${desired_inter_ca_idx}.csr.pem" \
        | sh
    [ $? -eq 0 ] || exit $?

    # KeyValue private key format pkcs8
    openssl pkcs8 -in "${intermediate_ca_dir}/intermediate_ca/${intermediate_ca_prefix}-${desired_inter_ca_idx}.key.pem" \
            ${password_cmd} \
            -topk8 -nocrypt \
            -out "${intermediate_ca_dir}/intermediate_ca/${intermediate_ca_prefix}-${desired_inter_ca_idx}.pkcs8.pem"

    echo "Signing the Intermediate Certificate with Root CA Cert"
    echo "-----------------------------------"
    password_cmd=" -passin pass:${root_ca_password} "

    openssl ca -batch \
        -config "${openssl_root_config_file}" \
        ${password_cmd} \
        -extensions v3_intermediate_ca \
        -days ${days_till_expire} -notext -md sha256 \
        -in "${intermediate_ca_dir}/intermediate_ca/${intermediate_ca_prefix}-${desired_inter_ca_idx}.csr.pem" \
        -out "${intermediate_ca_dir}/intermediate_ca/${intermediate_ca_prefix}-${desired_inter_ca_idx}.cert.pem"
    [ $? -eq 0 ] || exit $?
    chmod 444 "${intermediate_ca_dir}/intermediate_ca/${intermediate_ca_prefix}-${desired_inter_ca_idx}.cert.pem"
    [ $? -eq 0 ] || exit $?

    echo "Verify signature of the Intermediate Device Certificate with Root CA"
    echo "-----------------------------------"
    openssl verify \
            -CAfile "${root_ca_dir}/certs/${root_ca_prefix}.cert.pem" \
            "${intermediate_ca_dir}/intermediate_ca/${intermediate_ca_prefix}-${desired_inter_ca_idx}.cert.pem"
    [ $? -eq 0 ] || exit $?

    echo "Intermediate CA Certificate Generated At:"
    echo "-----------------------------------------"
    echo "    ${intermediate_ca_dir}/intermediate_ca/${intermediate_ca_prefix}-${desired_inter_ca_idx}.cert.pem"
    echo ""
    openssl x509 -noout -text \
            -in "${intermediate_ca_dir}/intermediate_ca/${intermediate_ca_prefix}-${desired_inter_ca_idx}.cert.pem"
    [ $? -eq 0 ] || exit $?

    echo "Create Root + Intermediate CA Chain Certificate"
    echo "-----------------------------------"
    cat "${intermediate_ca_dir}/intermediate_ca/${intermediate_ca_prefix}-${desired_inter_ca_idx}.cert.pem" \
        "${root_ca_dir}/certs/${root_ca_prefix}.cert.pem" > \
        "${source_chain_file}"
    [ $? -eq 0 ] || exit $?
    chmod 444 "${source_chain_file}"
    [ $? -eq 0 ] || exit $?

    echo "Root + Intermediate CA Chain Certificate Generated At:"
    echo "------------------------------------------------------"
    echo "    ${source_chain_file}"

    warn_certs_not_for_production
}

###############################################################################
# Generate a Certificate for a device using specific openssl extension and
# signed with either the root or intermediate cert.
###############################################################################
function generate_device_certificate_common()
{
    local common_name="${1}"
    local name_prefix="${2}"
    local certificate_dir="${3}"
    local intermediate_ca_password="${4}"
# device password
    local server_pfx_password="${9}"
# intermediate cert password
    local password_cmd=" -passin pass:${intermediate_ca_password} "
#    local password_device_cmd=" -passout pass:5678 "
    local openssl_config_file="${5}"
    local openssl_config_extension="${6}"
    local cert_type_diagnostic="${7}"
    local intermediate_ca_index="${8}"
    local file_name="${10}"
    local PARAMETER="server_ip=${RABBITMQ_IP} server_dns=${RABBITMQ_DNS} intermediate_idx=${intermediate_ca_index}"
    echo "PARAMETER: $PARAMETER"

    echo "Creating ${cert_type_diagnostic} Certificate using intermediate_ca_index: ${intermediate_ca_index}"
    echo "----------------------------------------"
    cd "${home_dir}"

    openssl "${algorithm}" \
            -out "${certificate_dir}/${name_prefix}_ca/${name_prefix}-${file_name}.key.pem" \
            ${key_bits_length} 
    [ $? -eq 0 ] || exit $?
    chmod 444 "${certificate_dir}/${name_prefix}_ca/${name_prefix}-${file_name}.key.pem"
    [ $? -eq 0 ] || exit $?

    echo "Create the ${cert_type_diagnostic} Certificate Request"
    echo "----------------------------------------"
    echo ${PARAMETER} \
    openssl req -config "${openssl_config_file}" \
        -key "${certificate_dir}/${name_prefix}_ca/${name_prefix}-${file_name}.key.pem" \
        -subj "$(makeCNsubject "${common_name}")$(makeOsubject "${ORGANIZATION_NAME}")" \
        -new -sha256 -out "${certificate_dir}/csr/${name_prefix}-${file_name}.csr.pem" \
        | sh
    [ $? -eq 0 ] || exit $?

    echo ${PARAMETER} \
    openssl ca -batch -config "${openssl_config_file}" \
            ${password_cmd} \
            -extensions "${openssl_config_extension}" \
            -days ${days_till_expire} -notext -md sha256 \
            -in "${certificate_dir}/csr/${name_prefix}-${file_name}.csr.pem" \
            -out "${certificate_dir}/${name_prefix}_ca/${name_prefix}-${file_name}.cert.pem" \
            | sh
    [ $? -eq 0 ] || exit $?
    chmod 444 "${certificate_dir}/${name_prefix}_ca/${name_prefix}-${file_name}.cert.pem"
    [ $? -eq 0 ] || exit $?

    echo "Verify signature of the ${cert_type_diagnostic}" \
         " certificate with the signer"
    echo "-----------------------------------"
    openssl verify \
            -CAfile "${certificate_dir}/intermediate_ca/${ca_chain_prefix}-${intermediate_ca_index}.ca.cert.pem" \
            "${certificate_dir}/${name_prefix}_ca/${name_prefix}-${file_name}.cert.pem"
    [ $? -eq 0 ] || exit $?

    echo "${cert_type_diagnostic} Certificate Generated At:"
    echo "----------------------------------------"
    echo "    ${certificate_dir}/${name_prefix}_ca/${name_prefix}-${file_name}.cert.pem"
    echo ""
    openssl x509 -noout -text \
            -in "${certificate_dir}/${name_prefix}_ca/${name_prefix}-${file_name}.cert.pem"
    [ $? -eq 0 ] || exit $?
    # not use pfx file
    # echo "Create the ${cert_type_diagnostic} PFX Certificate"
    # echo "----------------------------------------"
    # openssl pkcs12 -in "${certificate_dir}/device_ca/device-${common_name}.cert.pem" \
    #         -inkey "${certificate_dir}/device_ca/device-${common_name}.key.pem" \
    #         -password pass:${server_pfx_password} \
    #         -export -out "${certificate_dir}/device_ca/device-${common_name}.cert.pfx"
    # [ $? -eq 0 ] || exit $?
    # echo "${cert_type_diagnostic} PFX Certificate Generated At:"
    # echo "--------------------------------------------"
    # echo "    ${certificate_dir}/device_ca/device-${common_name}.cert.pfx"
    # [ $? -eq 0 ] || exit $?

    # KeyValue private key format pkcs8
    openssl pkcs8 -in "${certificate_dir}/${name_prefix}_ca/${name_prefix}-${file_name}.key.pem" \
            -passin pass:${server_pfx_password} \
            -topk8 -nocrypt \
            -out "${certificate_dir}/${name_prefix}_ca/${name_prefix}-${file_name}.pkcs8.pem"

}

###############################################################################
# Generate a certificate for a leaf device
# signed with either the root or intermediate cert.
###############################################################################
function generate_leaf_certificate()
{
    local common_name="${1}"
    local device_prefix="${2}"
    local certificate_dir="${3}"
    local ca_password="${4}"
    local openssl_config_file="${5}"
    local intermediate_ca_idx="${6}"
    local device_password="${7}"
    local extension_name="${8}"
    local file_name="${9}"

    generate_device_certificate_common "${common_name}" "${device_prefix}" \
                                       "${certificate_dir}" "${ca_password}" \
                                       "${openssl_config_file}" "${extension_name}" \
                                       "Leaf Device" "${intermediate_ca_idx}" \
                                       "${device_password}" "${file_name}"
}

###############################################################################
#  Creates required directories and removes left over cert files.
#  Run prior to creating Root CA; after that these files need to persist.
###############################################################################
function prepare_filesystem()
{
    if [ ! -f ${openssl_root_config_file} ]; then
        echo "Missing file ${openssl_root_config_file}"
        exit 1
    fi

    if [ ! -f ${openssl_intermediate_config_file} ]; then
        echo "Missing file ${openssl_intermediate_config_file}"
        exit 1
    fi

    rm -rf csr
    rm -rf private
    rm -rf certs
    rm -rf intermediate_ca
    rm -rf server_ca
    rm -rf device_ca
    rm -rf newcerts
    rm -rf keyvault

    mkdir -p csr
    mkdir -p private
    mkdir -p certs
    mkdir -p intermediate_ca
    mkdir -p server_ca
    mkdir -p device_ca
    mkdir -p newcerts
    mkdir -p keyvault/outbound
    mkdir -p keyvault/inbound

    rm -f ./index.txt
    touch ./index.txt

    rm -f ./serial
    echo 01 > ./serial
}

###############################################################################
# Generates a root and intermediate certificate for CA certs.
###############################################################################
function initial_cert_generation()
{
    prepare_filesystem
    generate_root_ca
    # generate_intermediate_ca
}

###############################################################################
# Generates a certificate for verification, chained directly to the root.
###############################################################################
function generate_verification_certificate()
{
    if [ -z $1 ]; then
        echo "Usage: create_verification_certificate <subjectName>"
        exit 1
    fi
    
    rm -f ./private/verification-code.key.pem
    rm -f ./certs/verification-code.cert.pem
    generate_leaf_certificate "${1}" "verification-code" \
                              "${root_ca_dir}" "${root_ca_password}" \
                              "${openssl_root_config_file} "                              
}

###############################################################################
# Generates a certificate for a device, chained directly to the root.
###############################################################################
function generate_device_certificate()
{
    if [ -z $1 ]; then
        echo "Usage: create_device_certificate <subjectName>"
        exit 1
    fi

    rm -f ./private/new-device.key.pem
    rm -f ./certs/new-device.key.pem
    rm -f ./certs/new-device-full-chain.cert.pem
    generate_leaf_certificate "${1}" "new-device" \
                              "${root_ca_dir}" "${root_ca_password}" \
                              "${openssl_root_config_file}"
}


###############################################################################
# Generates a certificate for a device, chained to the intermediate.
###############################################################################
function generate_device_certificate_from_intermediate()
{
    if [ -z $1 ]; then
        echo "Usage: create_device_certificate_from_intermediate <device_id> <intermediate_ca_idx>"
        exit 1
    fi
    echo "======> ${2}"
    # rm -f ./private/new-device.key.pem
    # rm -f ./certs/new-device.key.pem
    # rm -f ./certs/new-device-full-chain.cert.pem

    # Advantech IIOT
    local device_name="${1}"
    local device_password="${3}"
    local type_name="${4}"
    local file_name="${5}"
    # TODO: check if source_cert_file exists
    local desired_inter_ca_idx="${2}"
    # local current_inter_ca_idx=`cat intermediate_ca_idx.txt`
    # Copy corresponding intermediate CA files
    #local source_cert_file="./intermediate_ca/intermediate${desired_inter_ca_idx}.cert.pem"
    #local dest_cert_file="./intermediate_ca/intermediate.cert.pem"
    #local source_key_file="./intermediate_ca/intermediate${desired_inter_ca_idx}.key.pem"
    #local dest_key_file="./intermediate_ca/intermediate.key.pem"
    # Copy corresponding chain files
    #local source_chain_file="./intermediate_ca/chain${desired_inter_ca_idx}.ca.cert.pem"
    #local dest_chain_file="./intermediate_ca/chain.ca.cert.pem"

    # echo "current_inter_ca_idx: ${current_inter_ca_idx}"
    #echo "desired_inter_ca_idx: ${desired_inter_ca_idx}"

    #echo "copy source_cert_file======> ${source_cert_file}"
    #echo "copy source_key_file======> ${source_key_file}"

    #echo "copy ${source_cert_file} and ${source_key_file}"
    #cp -f ${source_cert_file} ${dest_cert_file}
    # check if command success
    #[ $? -eq 0 ] || exit $?
    #cp -f ${source_key_file} ${dest_key_file}
    # check if command success
    #[ $? -eq 0 ] || exit $?
    # save current intermediate index
    #echo "${desired_inter_ca_idx}" > intermediate_ca_idx.txt

    generate_leaf_certificate "${device_name}" "${type_name}" \
                              "${intermediate_ca_dir}" "${intermediate_ca_password}" \
                              "${openssl_intermediate_config_file}" "${desired_inter_ca_idx}" \
                              "${device_password}" "${EXTENSION_NAME}" \
                              "${file_name}"
}


###############################################################################
# Generates a certificate for a Edge device, chained to the intermediate.
###############################################################################
function generate_edge_device_certificate()
{
    local device_prefix="new-edge-device"
    if [ -z $1 ]; then
        echo "Usage: create_edge_device_certificate <subjectName>"
        exit 1
    fi
    rm -f ./private/new-edge-device.key.pem
    rm -f ./certs/new-edge-device.cert.pem
    rm -f ./certs/new-edge-device-full-chain.cert.pem

    # Note: Appending a '.ca' to the common name is useful in situations
    # where a user names their hostname as the edge device name.
    # By doing so we avoid TLS validation errors where we have a server or
    # client certificate where the hostname is used as the common name
    # which essentially results in "loop" for validation purposes.
    generate_device_certificate_common "${1}.ca" \
                                       "${device_prefix}" \
                                       "${intermediate_ca_dir}" \
                                       "${intermediate_ca_password}" \
                                       "${openssl_intermediate_config_file}" \
                                       "v3_intermediate_ca" "Edge Device"
}

set +x
if [ "${1}" == "create_root_and_intermediate" ]; then
    initial_cert_generation
elif [ "${1}" == "create_verification_certificate" ]; then
    generate_verification_certificate "${7}"
elif [ "${1}" == "generate_intermediate_ca" ]; then
    generate_intermediate_ca "${7}"
elif [ "${1}" == "create_device_certificate" ]; then
    generate_device_certificate "${7}"
elif [ "${1}" == "create_device_certificate_from_intermediate" ]; then
    generate_device_certificate_from_intermediate "${7}" "${8}" "${9}" "device" "${7}"
elif [ "${1}" == "create_server_certificate_from_intermediate" ]; then
    generate_device_certificate_from_intermediate "${7}" "${8}" "${9}" "server" "${8}"

elif [ "${1}" == "create_edge_device_certificate" ]; then
    generate_edge_device_certificate "${7}"
else
    echo "Usage: create_root_and_intermediate                                       # Creates a new root and intermediate certificates"
    echo "       generate_intermediate_ca                                           # Creates a intermediate certificate from root certificate"
    echo "       create_verification_certificate <subjectName>                      # Creates a verification certificate, signed with <subjectName>"
    echo "       create_device_certificate <subjectName>                            # Creates a device certificate signed by root with <subjectName>"
    echo "       create_device_certificate_from_intermediate <device_id> <ca_index> # Creates a device certificate signed by intermediate with <deviceId> and <intermediate_ca_index>"
    echo "       create_server_certificate_from_intermediate                        # Creates a server certificate signed by intermediate with <intermediate_ca_index>"
    echo "       create_edge_device_certificate <subjectName>                       # Creates an edge device certificate, signed with <subjectName>"
    exit 1
fi




warn_certs_not_for_production
